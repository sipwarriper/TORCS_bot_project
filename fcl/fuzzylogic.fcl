FUNCTION_BLOCK gear	// Block definition (there may be more than one block per file)

VAR_INPUT				// Define input variables
	rpm : REAL;
	accelerate: REAL;
END_VAR

VAR_OUTPUT				// Define output variable
	outgear: REAL;       //-1 shift down, 0 no shift, 1 shift up
END_VAR

FUZZIFY rpm			// Fuzzify input variable 'rpm': {'low', 'medium' , 'high'}
	TERM tooLow := (0, 1) (2000,1) (3000, 0);
	TERM low := (2000, 0) (3000,1) (4000,1) (5000, 0);
	TERM medium:= (4000, 0) (5000, 1) (7500, 1) (8500, 0);
	TERM high:= (7500, 0) (8500, 1) (10000, 1);
END_FUZZIFY

FUZZIFY accelerate			// Fuzzify input variable 'accelerate': { 'no', 'yes' }
	TERM no := (0, 1) (0.0001, 0);
	TERM yes := (0, 0) (0.0001, 1) (1, 1);
END_FUZZIFY

DEFUZZIFY outgear			// Defzzzify output variable 'outgear' : {'shiftdown', 'keep', 'shiftup' }
	TERM shiftdown := -1;
	TERM keep := 0;
	TERM shiftup := 1;
	METHOD : COGS;		// Use 'Center Of Gravity' defuzzification method
	DEFAULT := 0;		// Default value is 0 (if no rule activates defuzzifier)
END_DEFUZZIFY

RULEBLOCK No1
	AND : MIN;			// Use 'min' for 'and' (also implicit use 'max' for 'or' to fulfill DeMorgan's Law)
	ACT : MIN;			// Use 'min' activation method
	ACCU : MAX;			// Use 'max' accumulation method

	RULE 1 : IF accelerate IS yes AND rpm IS high THEN outgear IS shiftup;
	RULE 2 : IF accelerate IS yes AND rpm IS low THEN outgear IS keep;
	RULE 3 : IF rpm IS tooLow THEN outgear IS shiftdown;
	RULE 4 : IF rpm IS medium THEN outgear IS keep;
	RULE 5 : IF accelerate IS no AND rpm IS low THEN outgear IS shiftdown;
	RULE 6 : IF accelerate IS no AND rpm IS high THEN outgear IS keep;

END_RULEBLOCK

END_FUNCTION_BLOCK


//--------------------------SEPARADOR---------------------------------------------------------------\\


FUNCTION_BLOCK acceleration	// Block definition (there may be more than one block per file)

VAR_INPUT				// Define input variables
	speed : REAL;
	distanceFront: REAL;
	straight : REAL;
END_VAR

VAR_OUTPUT				// Define output variable
	accel: REAL;
END_VAR

FUZZIFY speed			// Fuzzify input variable 'speed': {'slow', 'average' , 'fast'}
	TERM slow := (0, 1) (70, 1) (100, 0);
	TERM average:= (60, 0) (100, 1) (130, 1) (160, 0);
	TERM fast:= (130, 0) (160, 1) (300, 1);
END_FUZZIFY

FUZZIFY straight			// Fuzzify input variable 'straight': { 'yes', 'no' }
	TERM yes := (0, 1) (0.05, 1) (0.1, 0);
	TERM no := (0.05, 0) (0.1, 1) (1.25, 1);
END_FUZZIFY

FUZZIFY distanceFront			// Fuzzify input variable 'distanceFront': { 'near', 'far' }
	TERM near := (0, 1) (60, 1) (100, 0);
    TERM far := (60, 0) (100, 1) (200, 1);
END_FUZZIFY

DEFUZZIFY accel			// Defzzzify output variable 'outgear' : {'shiftdown', 'keep', 'shiftup' }
	TERM fullBrake := (-1, 1) (-0.4, 1) (0, 0);
	TERM nothing := (0, 0) (0,1) (0.3, 1) (0.5, 0);
	TERM mediumAccel := (0.1, 0) (0.2, 1) (0.3, 1);
	TERM fullAccel := (0.3, 0) (0.7, 1) (1,1);
	METHOD : COG;		// Use 'Center Of Gravity' defuzzification method
	DEFAULT := 1;		// Default value is 0 (if no rule activates defuzzifier)
END_DEFUZZIFY

RULEBLOCK No1
	AND : MIN;			// Use 'min' for 'and' (also implicit use 'max' for 'or' to fulfill DeMorgan's Law)
	ACT : MIN;			// Use 'min' activation method
	ACCU : MAX;			// Use 'max' accumulation method

    RULE 1 : IF distanceFront IS near AND speed IS average THEN accel IS nothing;
    RULE 2 : IF distanceFront IS near AND speed IS slow AND straight IS yes THEN accel IS fullAccel;
    RULE 3 : IF distanceFront IS near AND speed IS slow AND straight IS no THEN accel IS mediumAccel;
    RULE 4 : IF distanceFront IS far THEN accel IS fullAccel;
    RULE 5 : IF distanceFront IS near AND speed IS fast THEN accel IS fullBrake;

END_RULEBLOCK

END_FUNCTION_BLOCK

FUNCTION_BLOCK turn	// Block definition (there may be more than one block per file)

VAR_INPUT				// Define input variables
	deviationAngle : REAL;
	distanceEdge : REAL;
	distanceFront : REAL;
	straight : REAL;
END_VAR

VAR_OUTPUT				// Define output variable
	steering: REAL;
END_VAR

FUZZIFY deviationAngle			// Fuzzify input variable 'deviationAngle': {'left', 'no' , 'right'}
	TERM left := (-180, 1) (-45, 1) (0, 0);
	TERM no := (-45, 0) (0, 1) (45, 0);
	TERM right := (0, 0) (45, 1) (180, 1);
END_FUZZIFY

FUZZIFY distanceEdge			// Fuzzify input variable 'distanceEdge': { 'left', 'center', 'right' }
	TERM right := (-9, 1) (-0.6, 1) (-0.3, 0);
	TERM center := (-0.6, 0) (-0.3, 1) (0.3, 1) (0.6, 0);
	TERM left := (0.3, 0) (0.6, 1) (9, 1);
END_FUZZIFY

FUZZIFY distanceFront			// Fuzzify input variable 'distanceFront': { 'near', 'far' }
	TERM near := (0, 1) (60, 1) (100, 0);
	TERM far := (60, 0) (100, 1) (200, 1);
END_FUZZIFY

FUZZIFY straight			// Fuzzify input variable 'straight': { 'yes', 'no' }
	TERM yes := (0, 1) (0.05, 1) (0.1, 0);
	TERM no := (0.05, 0) (0.1, 1) (1.25, 1);
END_FUZZIFY

DEFUZZIFY steering			// Defzzzify output variable 'steering' : {'turnLeft', 'nothing', 'turnRight' }
	TERM turnRight := (-1, 1) (-0.2, 1) (-0.1, 0);
	TERM smoothTurnRight := (-0.2, 0) (-0.1, 1) (0, 0);
	TERM nothing := (-0.1, 0) (0,1) (0.1, 0);
	TERM smoothTurnLeft := (0, 0) (0.1, 1) (0.15, 0);
	TERM turnLeft := (0.1, 0) (0.2, 1) (1, 1);
	METHOD : COG;		// Use 'Center Of Gravity' defuzzification method
	DEFAULT := 0;		// Default value is 0 (if no rule activates defuzzifier)
END_DEFUZZIFY

RULEBLOCK No1
	AND : MIN;			// Use 'min' for 'and' (also implicit use 'max' for 'or' to fulfill DeMorgan's Law)
	ACT : MIN;			// Use 'min' activation method
	ACCU : MAX;			// Use 'max' accumulation method

/*
    RULE 1 : IF straight IS yes AND distanceEdge IS left AND distanceFront IS far THEN steering IS smoothTurnRight;
    RULE 2 : IF straight IS yes AND distanceEdge IS right AND distanceFront IS far THEN steering IS smoothTurnLeft;
    RULE 3 : IF straight IS yes AND distanceEdge IS center AND distanceFront IS far THEN steering IS nothing;
    RULE 4 : IF straight IS yes AND distanceFront IS near THEN steering IS nothing;

    //RULE 4 : IF straight IS yes AND distanceEdge IS left AND distanceFront IS near THEN steering IS turnRight;
    //RULE 5 : IF straight IS yes AND distanceEdge IS right AND distanceFront IS near THEN steering IS turnLeft;
    //RULE 6 : IF straight IS yes AND distanceEdge IS center AND distanceFront IS near THEN steering IS nothing;

    RULE 7 : IF straight IS yes AND deviationAngle IS left THEN steering IS smoothTurnRight;
    RULE 8 : IF straight IS yes AND deviationAngle IS no THEN steering IS nothing;
    RULE 9 : IF straight IS yes AND deviationAngle IS right THEN steering IS smoothTurnLeft;

    RULE 10 : IF straight IS no AND distanceEdge IS left AND deviationAngle IS left THEN steering IS smoothTurnRight;
    RULE 10 : IF straight IS no AND distanceEdge IS left AND deviationAngle IS right THEN steering IS smoothTurnRight;
    RULE 11 : IF straight IS no AND distanceEdge IS right THEN steering IS turnLeft;
    RULE 12 : IF straight IS no AND distanceEdge IS center THEN steering IS nothing;
*/

    RULE 1 : IF straight IS yes AND deviationAngle IS no THEN steering IS nothing;
    RULE 2 : IF straight IS yes AND deviationAngle IS left THEN steering IS smoothTurnRight;
    RULE 3 : IF straight IS yes AND deviationAngle IS right THEN steering IS smoothTurnLeft;
    RULE 2 : IF straight IS no AND distanceFront IS near AND distanceEdge IS left THEN steering IS turnRight;
    RULE 3 : IF straight IS no AND distanceFront IS near AND distanceEdge IS center THEN steering IS nothing;
    RULE 4 : IF straight IS no AND distanceFront IS near AND distanceEdge IS right THEN steering IS turnLeft;
    RULE 5 : IF straight IS no AND deviationAngle IS left THEN steering IS turnRight;
    RULE 6 : IF straight IS no AND deviationAngle IS no THEN steering IS nothing;
    RULE 7 : IF straight IS no AND deviationAngle IS right THEN steering IS turnLeft;
END_RULEBLOCK

END_FUNCTION_BLOCK